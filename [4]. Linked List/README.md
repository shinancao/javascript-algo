## 什么是链表

链表类似于数组，也是一系列数据项。但不像数组会占用一整块连续的内存，链表占用的内存是不连续的，它通过“指针”将零散的内存串联起来使用。其中，我们把内存块称为**结点**。为了将所有结点串起来，每个链表除了存储数据之外，还需要记录链上的下一个结点的地址，我们把记录下个结点地址的指针叫作**后继指针next**。

链表虽然简单，但却很重要，它和数组是真正从物理存储上不同的两种结构，所以也是后面各种更进一步的数据结构的基础。

## 常见的链表结构

### 单链表

单链表是最简单、最常用的链表结构。说它简单，是因为它的结点非常简单，结点中只要存储数据和后继指针`next`即可。通常我们把链表中的第一个结点叫作**头结点**，最后一个结点叫作**尾结点**。通过头结点可以遍历整个链表，尾结点的`next`指针指向空地址。

```
           +-------+      +-------+      +-------+
           |       |      |       |      |       |
head --->  | node0 | ---> | node1 | ---> | node2 | ---> nil
           |       |      |       |      |       |
           +-------+      +-------+      +-------+
```

### 双向链表

在单链表的结点中，再多加一个指针指向该结点的前一个结点，此时的链表就变成了双向链表，多加的这个指针通常叫作**前驱指针prev**。所以双向链表比单链表需要更多的存储空间。

```
           +-------+      +-------+      +-------+
head --->  |       | ---> |       | ---> |       | ---> nil
           | node0 |      | node1 |      | node2 | 
nil  <---  |       | <--- |       | <--- |       | <--- tail
           +-------+      +-------+      +-------+
```

### 循环链表

如果单链表的尾结点的`next`指针不指向空地址，而指向头结点，此时就构成了一个**循环链表**。循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环形结构特点时，就特变适合采用循环链表。

```
           +-------+      +-------+      +-------+   
           |       |      |       |      |       |   
head --->  | node0 | ---> | node1 | ---> | node2 | ---> head
           |       |      |       |      |       |
           +-------+      +-------+      +-------+
```

## 链表的性能

链表和数组一样，也支持查询、插入、删除等操作，但双向链表因为比单链表的结点中多存储了指向前驱结点的指针，所以很多情况省去了遍历链表查找结点的时间。这也是拿空间换时间的一种吧。

链表结构 | 查询第k个结点 | 删除指定结点 | 添加结点到指定位置 | 在链尾追加结点
------- | ------- | ------- | ------- | -------
单向链表 | O(n)    | O(n)    | O(n)    | O(1)
双向链表 | O(n)    | O(1)    | O(n)    | O(1)

链表不像数组支持随机访问，涉及到在指定`index`处的操作，都需要遍历计数找到对应的结点，所以时间复杂度会是`O(n)`。

## 注意点

在链表上执行操作的时候，记得要更新`next`和`prev`指针，`head`和`tail`也需要考虑，否则链表可能变得不正确，在某些情况会crash。

在处理链表时，可以使用递归：先处理第一个元素，然后递归调用函数处理剩余部分，在`next`为空时即处理完了。

## 源码目录

序号 | 内容
---- | ----
4.1 | 实现单链表
4.2 | 实现非循环双向链表
