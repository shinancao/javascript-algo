## 什么是散列表？

散列表又叫哈希表，英文名：Hash Table。它让我们可以通过一个`key`存储和获取对象。看起来用法就和我们在`Objective-C`和`Swift`中的字典一样，实际上字典确实就是用散列表实现的。这也是为什么`Swift`中字典的`key`都需要实现`Hashable` protocol。

## 散列表是如何工作的？

散列表中的元素实际上都是存在一个数组中的，同时它还提供了一个计算函数，可以把传入的`key`转换成数组的`index`，这样就可以直接从数组中取出元素了。

例如我们在hashTable中存了如下两个键值对，`firstName`映射为`index` 3，`hobbies`映射为`index` 1。 

```
hashTable["firstName"] = "Steve"
hashTable["hobbies"] = "Programming Swift"

The hashTable array:
+-------------+
| 0:          |
+-------------+
| 1: hobbies  |----> Programming Swift
+-------------+
| 2:          |
+-------------+
| 3: firstName|----> Steve
+-------------+
| 4:          |
+-------------+
```

在`Swift`中，因为字典中的`key`实现了`Hashable` protocol，所以可以得到`key`的`hashValue`，它会返回一长串数字。假如"firstName".hashValue返回-4799450059917011053，则可以这样计算`index`：

```
abs(-4799450059917011053) % 5 = 3
```

得益于数组，使得散列表的插入、获取和移除操作的时间复杂度都为`O(1)`。

## 如何设计一个散列表？

通常要设计一个散列表，我们要考虑以下几点：

* 设计一个合适的散列函数；
* 选择合适的散列冲突解决办法;
* 定义装载因子阀值，并且设计动态扩容/缩容策略。

### 散列函数

我们上面说到的把`key`映射成数组的`index`的函数，就是散列函数。散列函数要尽量设计的简单，很显然这是一个会被反复调用的函数，如果计算耗时久会影响散列表整体的性能。同时散列函数生成的值要尽量分布均匀。

### 散列冲突

理想状态下我们希望一个`key`能得到一个唯一的`index`，但在实际情况下，要找到一个不同的`key`对应的散列值不同的散列函数几乎是不可能的。如果不同的`key`经过散列函数的计算得到了相同的`index`，此时就发生了散列冲突。解决散列冲突常用的方法有两种：开放寻址法和链表法。

**开放寻址法**的核心思想是，通过一定方式再重新探测出一个位置来插入元素。一个种比较简单的方式是线性探测，比如在hash(key)处已经有元素存在了，则继续hash(key)+1、hash(key)+2...直到找到一个合适的位置。用线性探测时，查找操作不能在hash(key)不是该元素或者空就直接返回没有找到，出现空是有可能我们之前删除了跟它冲突的元素。所以要一直探测下去，直到把整个数组中可以放置该元素的位置都访问后才能确定该元素是否存在。最坏的情况下，插入、删除、查找的时间复杂度为`O(n)`。

**链表法**的做法是，数组中不直接存储插入的元素，而是存一个链表，把散列值相同的元素放在同一个链表中。

```
buckets:
+-----+
|  0  |
+-----+      +----------------------------+
|  1  |----->| hobbies: Programming Swift |
+-----+      +----------------------------+
|  2  |
+-----+      +------------------+      +------------------+
|  3  |----->| firstName: Steve |----->| lastName: Jobs   |
+-----+      +------------------+      +------------------+
|  4  |
+-----+      
```

这种情况下，当插入的时候，计算出散列的位置，再插入到链表中即可，时间复杂度是`O(1)`。查找和删除时，时间复杂与链表的长度成正比，对于散列均匀的散列函数来说，时间复杂度为`O(n/k)`，n 为元素的个数，k 为“桶”的个数。

### 装载因子与扩容/缩容

先来看一下**装载因子**的计算公式：

```
装在因子 = 已存储元素的个数/数组最大长度
```

也就是说装载因子描述了一个散列表的填充程度，越大说明已经存储的元素就越多，当装载因子为1时，散列表就已经填满了。我们可以定义一个装载因子的阀值，当超过这个阀值时就对散列表进行扩容。对于扩容的策略，最直接的就是重新申请一个更大的数组，然后重新计算元素的散列值再放于新的数组。如果数据量小可以一次性搬移过去，如果数据量非常大，可以在之后每插入一个新的元素时，就搬移一个旧数组中的元素。

当然也存在散列表大部分为空的情况，可以采取一定的方式来判断散列表是否大部分是空，然后进行缩容。比如出现在Objective-C的`__weak`的实现中，散列表的缩容策略是，数组中元素的个数大于1024，并且实际元素的个数还不足其1/16，进行缩容，缩减到当前数组长度的1/8。

*objc在`__weak`的实现中对散列表有着广泛的应用，感兴趣的同学可以看一下我之前的[这篇文章](http://shinancao.cn/2019/07/15/iOS-weak/)，了解一下散列表在实际开发中的使用。*

## 源码目录

序号 | 内容
---- | ----
7.1  | 实现一个散列表，用链表法解决散列冲突
7.2  | LRUCache